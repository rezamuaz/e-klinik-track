// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 14_r3_view_roles.sql

package pg

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
)

const createR3ViewRole = `-- name: CreateR3ViewRole :one
INSERT INTO r3_view_roles (
  view_id, role_id, action, created_by
)
VALUES (
  $1,
  $2,
  $3,
  $4
)
RETURNING id, view_id, role_id, action, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type CreateR3ViewRoleParams struct {
	ViewID    int32   `json:"view_id"`
	RoleID    int32   `json:"role_id"`
	Action    *string `json:"action"`
	CreatedBy *string `json:"created_by"`
}

func (q *Queries) CreateR3ViewRole(ctx context.Context, arg CreateR3ViewRoleParams) (R3ViewRole, error) {
	row := q.db.QueryRow(ctx, createR3ViewRole,
		arg.ViewID,
		arg.RoleID,
		arg.Action,
		arg.CreatedBy,
	)
	var i R3ViewRole
	err := row.Scan(
		&i.ID,
		&i.ViewID,
		&i.RoleID,
		&i.Action,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteR3ViewRole = `-- name: DeleteR3ViewRole :exec
UPDATE r3_view_roles
SET
  deleted_by = $1,
  deleted_at = now()
WHERE id = $2
  AND deleted_at IS NULL
`

type DeleteR3ViewRoleParams struct {
	DeletedBy *string   `json:"deleted_by"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) DeleteR3ViewRole(ctx context.Context, arg DeleteR3ViewRoleParams) error {
	_, err := q.db.Exec(ctx, deleteR3ViewRole, arg.DeletedBy, arg.ID)
	return err
}

const getR3ViewRoleByID = `-- name: GetR3ViewRoleByID :one
SELECT id, view_id, role_id, action, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r3_view_roles
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetR3ViewRoleByID(ctx context.Context, id uuid.UUID) (R3ViewRole, error) {
	row := q.db.QueryRow(ctx, getR3ViewRoleByID, id)
	var i R3ViewRole
	err := row.Scan(
		&i.ID,
		&i.ViewID,
		&i.RoleID,
		&i.Action,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getR3ViewRoleByRoleID = `-- name: GetR3ViewRoleByRoleID :many
SELECT id,view_id,role_id
FROM r3_view_roles
WHERE role_id = $1
  AND deleted_at IS NULL
`

type GetR3ViewRoleByRoleIDRow struct {
	ID     uuid.UUID `json:"id"`
	ViewID int32     `json:"view_id"`
	RoleID int32     `json:"role_id"`
}

func (q *Queries) GetR3ViewRoleByRoleID(ctx context.Context, roleID int32) ([]GetR3ViewRoleByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, getR3ViewRoleByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetR3ViewRoleByRoleIDRow{}
	for rows.Next() {
		var i GetR3ViewRoleByRoleIDRow
		if err := rows.Scan(&i.ID, &i.ViewID, &i.RoleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listR3ViewRoles = `-- name: ListR3ViewRoles :many
SELECT id, view_id, role_id, action, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r3_view_roles
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListR3ViewRoles(ctx context.Context) ([]R3ViewRole, error) {
	rows, err := q.db.Query(ctx, listR3ViewRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []R3ViewRole{}
	for rows.Next() {
		var i R3ViewRole
		if err := rows.Scan(
			&i.ID,
			&i.ViewID,
			&i.RoleID,
			&i.Action,
			&i.DeletedBy,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateR3ViewRole = `-- name: UpdateR3ViewRole :one
UPDATE r3_view_roles
SET
  view_id = COALESCE($1, view_id),
  role_id = COALESCE($2, role_id),
  action = COALESCE($3, action),
  updated_by = $4,
  updated_at = now()
WHERE id = $5
  AND deleted_at IS NULL
RETURNING id, view_id, role_id, action, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type UpdateR3ViewRoleParams struct {
	ViewID    *int32    `json:"view_id"`
	RoleID    *int32    `json:"role_id"`
	Action    *string   `json:"action"`
	UpdatedBy *string   `json:"updated_by"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) UpdateR3ViewRole(ctx context.Context, arg UpdateR3ViewRoleParams) (R3ViewRole, error) {
	row := q.db.QueryRow(ctx, updateR3ViewRole,
		arg.ViewID,
		arg.RoleID,
		arg.Action,
		arg.UpdatedBy,
		arg.ID,
	)
	var i R3ViewRole
	err := row.Scan(
		&i.ID,
		&i.ViewID,
		&i.RoleID,
		&i.Action,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const viewRolesSyncDeleteHard = `-- name: ViewRolesSyncDeleteHard :exec
WITH new_views AS (
    -- sqlc.arg('view_ids') adalah array of INTEGER yang dikirim dari input admin
    SELECT unnest($2::int[]) AS view_id  
)
DELETE FROM r3_view_roles r3
WHERE r3.role_id = $1 -- $1 = role_id target
  -- Hapus semua policy yang dimiliki role, tetapi TIDAK ada di daftar view_id baru
  AND r3.view_id NOT IN (SELECT view_id FROM new_views)
`

type ViewRolesSyncDeleteHardParams struct {
	RoleID  int32   `json:"role_id"`
	ViewIds []int32 `json:"view_ids"`
}

func (q *Queries) ViewRolesSyncDeleteHard(ctx context.Context, arg ViewRolesSyncDeleteHardParams) error {
	_, err := q.db.Exec(ctx, viewRolesSyncDeleteHard, arg.RoleID, arg.ViewIds)
	return err
}

const viewRolesSyncInsertHard = `-- name: ViewRolesSyncInsertHard :exec
INSERT INTO r3_view_roles (
    view_id, 
    role_id, 
    created_by
)
SELECT 
    view_id, 
    $1, 
    $2
FROM 
    unnest($3::int[]) AS new_view(view_id) -- Mengambil array view_ids baru
ON CONFLICT (view_id, role_id) DO NOTHING
`

type ViewRolesSyncInsertHardParams struct {
	RoleID        int32   `json:"role_id"`
	CurrentUserID *string `json:"current_user_id"`
	ViewIds       []int32 `json:"view_ids"`
}

func (q *Queries) ViewRolesSyncInsertHard(ctx context.Context, arg ViewRolesSyncInsertHardParams) error {
	_, err := q.db.Exec(ctx, viewRolesSyncInsertHard, arg.RoleID, arg.CurrentUserID, arg.ViewIds)
	return err
}
