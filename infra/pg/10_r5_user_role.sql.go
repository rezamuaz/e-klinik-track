// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 10_r5_user_role.sql

package pg

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
)

const createUserRole = `-- name: CreateUserRole :exec
INSERT INTO r5_user_roles (user_id, role_id, is_active, created_by)
VALUES ($1, $2, true, $3)
ON CONFLICT (user_id, role_id)
DO NOTHING
`

type CreateUserRoleParams struct {
	UserID    uuid.UUID `json:"user_id"`
	RoleID    int32     `json:"role_id"`
	CreatedBy *string   `json:"created_by"`
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
	_, err := q.db.Exec(ctx, createUserRole, arg.UserID, arg.RoleID, arg.CreatedBy)
	return err
}

const createUserRolesBulk = `-- name: CreateUserRolesBulk :many
INSERT INTO r5_user_roles (
  user_id,
  role_id,
  is_active,
  created_by
)
SELECT
  unnest($1::uuid[]),
  unnest($2::uuid[]),
  unnest($3::bool[]),
  unnest($4::text[])
RETURNING id, user_id, role_id, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type CreateUserRolesBulkParams struct {
	UserIds    []uuid.UUID `json:"user_ids"`
	RoleIds    []uuid.UUID `json:"role_ids"`
	IsActives  []bool      `json:"is_actives"`
	CreatedBys []string    `json:"created_bys"`
}

func (q *Queries) CreateUserRolesBulk(ctx context.Context, arg CreateUserRolesBulkParams) ([]R5UserRole, error) {
	rows, err := q.db.Query(ctx, createUserRolesBulk,
		arg.UserIds,
		arg.RoleIds,
		arg.IsActives,
		arg.CreatedBys,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []R5UserRole{}
	for rows.Next() {
		var i R5UserRole
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.IsActive,
			&i.DeletedBy,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteUnRegisterRole = `-- name: DeleteUnRegisterRole :exec
WITH new_roles AS (
    SELECT unnest($2::int[]) AS role_id  -- $2 = array of role_ids dari input user
)
DELETE FROM r5_user_roles ur
WHERE ur.user_id = $1
  AND ur.role_id NOT IN (SELECT role_id FROM new_roles)
`

type DeleteUnRegisterRoleParams struct {
	UserID  uuid.UUID `json:"user_id"`
	RoleIds []int32   `json:"role_ids"`
}

func (q *Queries) DeleteUnRegisterRole(ctx context.Context, arg DeleteUnRegisterRoleParams) error {
	_, err := q.db.Exec(ctx, deleteUnRegisterRole, arg.UserID, arg.RoleIds)
	return err
}

const getUserMenuViews = `-- name: GetUserMenuViews :many
SELECT DISTINCT
    r1.id AS view_id,
    r1.label AS view_label,
    r1.view,
    r1.resource_key,
    r1.action
FROM
    r5_user_roles ur 
JOIN
    r4_roles r4 ON ur.role_id = r4.id
JOIN
    r3_view_roles r3 ON ur.role_id = r3.role_id
JOIN
    r1_views r1 ON r3.view_id = r1.id
WHERE
    ur.user_id = $1
    
    -- Filter View Murni
    AND r1.view = 'view'
    
    -- Filter Status Aktif
    AND ur.deleted_at IS NULL
    AND r3.deleted_at IS NULL
    AND r1.is_active = TRUE
    AND r4.is_active = TRUE
`

type GetUserMenuViewsRow struct {
	ViewID      int32   `json:"view_id"`
	ViewLabel   string  `json:"view_label"`
	View        *string `json:"view"`
	ResourceKey string  `json:"resource_key"`
	Action      string  `json:"action"`
}

func (q *Queries) GetUserMenuViews(ctx context.Context, userID uuid.UUID) ([]GetUserMenuViewsRow, error) {
	rows, err := q.db.Query(ctx, getUserMenuViews, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserMenuViewsRow{}
	for rows.Next() {
		var i GetUserMenuViewsRow
		if err := rows.Scan(
			&i.ViewID,
			&i.ViewLabel,
			&i.View,
			&i.ResourceKey,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRolesByUserID = `-- name: GetUserRolesByUserID :many
SELECT
    ur.id,
    ur.nama
FROM r5_user_roles uur
JOIN r4_roles ur
    ON ur.id = uur.role_id
WHERE uur.user_id = $1
  AND uur.deleted_at IS NULL
  AND ur.deleted_at IS NULL
`

type GetUserRolesByUserIDRow struct {
	ID   int32  `json:"id"`
	Nama string `json:"nama"`
}

func (q *Queries) GetUserRolesByUserID(ctx context.Context, userID uuid.UUID) ([]GetUserRolesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserRolesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRolesByUserIDRow{}
	for rows.Next() {
		var i GetUserRolesByUserIDRow
		if err := rows.Scan(&i.ID, &i.Nama); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
