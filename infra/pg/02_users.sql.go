// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 02_users.sql

package pg

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

const countDistinctUserKehadiran = `-- name: CountDistinctUserKehadiran :one
SELECT COUNT(DISTINCT k.user_id) AS total
FROM kehadiran k
JOIN users u ON u.id = k.user_id
WHERE
  k.deleted_at IS NULL
  AND ($1::uuid IS NULL OR k.kontrak_id = $1::uuid)
  AND ($2::uuid IS NULL OR k.mata_kuliah_id = $2::uuid)
  AND ($3::uuid IS NULL OR k.pembimbing_id = $3::uuid)
  AND ($4::uuid IS NULL OR k.pembimbing_klinik = $4::uuid)
  AND k.tgl_kehadiran BETWEEN $5::date AND $6::date
`

type CountDistinctUserKehadiranParams struct {
	KontrakID        *uuid.UUID  `json:"kontrak_id"`
	MataKuliahID     *uuid.UUID  `json:"mata_kuliah_id"`
	PembimbingID     *uuid.UUID  `json:"pembimbing_id"`
	PembimbingKlinik *uuid.UUID  `json:"pembimbing_klinik"`
	TglMulai         pgtype.Date `json:"tgl_mulai"`
	TglAkhir         pgtype.Date `json:"tgl_akhir"`
}

func (q *Queries) CountDistinctUserKehadiran(ctx context.Context, arg CountDistinctUserKehadiranParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDistinctUserKehadiran,
		arg.KontrakID,
		arg.MataKuliahID,
		arg.PembimbingID,
		arg.PembimbingKlinik,
		arg.TglMulai,
		arg.TglAkhir,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(DISTINCT u.id)::bigint
FROM public.users u
LEFT JOIN public.r5_user_roles ur
  ON u.id = ur.user_id
WHERE 
  u.deleted_at IS NULL
  AND ($1::text IS NULL OR u.nama ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR u.username ILIKE '%' || $2 || '%')
  AND ($3::boolean IS NULL OR u.is_active = $3::boolean)
  AND (
    $4::int[] IS NULL 
    OR array_length($4::int[], 1) IS NULL 
    OR ur.role_id = ANY($4::int[])
  )
`

type CountUsersParams struct {
	Nama     *string `json:"nama"`
	Username *string `json:"username"`
	IsActive *bool   `json:"is_active"`
	Roles    []int32 `json:"roles"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers,
		arg.Nama,
		arg.Username,
		arg.IsActive,
		arg.Roles,
	)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (
  nama,
  username,
  password
) VALUES (
  $1,$2,$3
) ON CONFLICT (username) DO UPDATE SET 
nama = $1,
password = $3
RETURNING id, nama, username, password, last_active, is_active, locked_until, failed_attempts, last_failed_at, refresh, deleted_by, deleted_at, updated_note, updated_by, updated_at, created_by, created_at, CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type CreateOrUpdateUserParams struct {
	Nama     string `json:"nama"`
	Username string `json:"username"`
	Password string `json:"password"`
}

type CreateOrUpdateUserRow struct {
	ID             uuid.UUID          `json:"id"`
	Nama           string             `json:"nama"`
	Username       string             `json:"username"`
	Password       string             `json:"password"`
	LastActive     pgtype.Timestamptz `json:"last_active"`
	IsActive       bool               `json:"is_active"`
	LockedUntil    pgtype.Timestamptz `json:"locked_until"`
	FailedAttempts *int32             `json:"failed_attempts"`
	LastFailedAt   pgtype.Timestamptz `json:"last_failed_at"`
	Refresh        *string            `json:"refresh"`
	DeletedBy      *string            `json:"deleted_by"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	UpdatedNote    *string            `json:"updated_note"`
	UpdatedBy      *string            `json:"updated_by"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CreatedBy      *string            `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Operation      string             `json:"operation"`
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (CreateOrUpdateUserRow, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser, arg.Nama, arg.Username, arg.Password)
	var i CreateOrUpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.Password,
		&i.LastActive,
		&i.IsActive,
		&i.LockedUntil,
		&i.FailedAttempts,
		&i.LastFailedAt,
		&i.Refresh,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedNote,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Operation,
	)
	return i, err
}

const delUser = `-- name: DelUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DelUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delUser, id)
	return err
}

const getByUsername = `-- name: GetByUsername :one
SELECT username,password FROM users
WHERE username = $1
`

type GetByUsernameRow struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) GetByUsername(ctx context.Context, username string) (GetByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getByUsername, username)
	var i GetByUsernameRow
	err := row.Scan(&i.Username, &i.Password)
	return i, err
}

const getUserActiveStatus = `-- name: GetUserActiveStatus :one
SELECT is_active FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserActiveStatus(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, getUserActiveStatus, username)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, nama, username, password, last_active, is_active, locked_until, failed_attempts, last_failed_at, refresh, deleted_by, deleted_at, updated_note, updated_by, updated_at, created_by, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.Password,
		&i.LastActive,
		&i.IsActive,
		&i.LockedUntil,
		&i.FailedAttempts,
		&i.LastFailedAt,
		&i.Refresh,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedNote,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserDetail = `-- name: GetUserDetail :one
SELECT 
  u.id,
  u.nama,
  u.username,
  u.last_active,
  u.is_active,
  u.created_by,
  u.created_at,
  COALESCE(string_agg(DISTINCT ur.nama, ', '), '')::text AS roles
FROM users u
LEFT JOIN r5_user_roles uur 
  ON uur.user_id = u.id 
  AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur 
  ON ur.id = uur.role_id 
  AND ur.deleted_at IS NULL
WHERE u.id = $1
GROUP BY u.id, u.nama, u.username, u.last_active, u.is_active, u.created_by, u.created_at
`

type GetUserDetailRow struct {
	ID         uuid.UUID          `json:"id"`
	Nama       string             `json:"nama"`
	Username   string             `json:"username"`
	LastActive pgtype.Timestamptz `json:"last_active"`
	IsActive   bool               `json:"is_active"`
	CreatedBy  *string            `json:"created_by"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Roles      string             `json:"roles"`
}

func (q *Queries) GetUserDetail(ctx context.Context, id uuid.UUID) (GetUserDetailRow, error) {
	row := q.db.QueryRow(ctx, getUserDetail, id)
	var i GetUserDetailRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.LastActive,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Roles,
	)
	return i, err
}

const getUsersByRoles = `-- name: GetUsersByRoles :many
SELECT 
    u.id AS user_id,
    u.nama AS nama_user,
    r.role_id
FROM 
    public.users u
JOIN 
    public.r5_user_roles r 
    ON u.id = r.user_id
WHERE 
    r.role_id = ANY($1::int[])
    AND r.is_active = TRUE
    AND u.is_active = TRUE
ORDER BY 
    u.nama
`

type GetUsersByRolesRow struct {
	UserID   uuid.UUID `json:"user_id"`
	NamaUser string    `json:"nama_user"`
	RoleID   int32     `json:"role_id"`
}

func (q *Queries) GetUsersByRoles(ctx context.Context, roleIds []int32) ([]GetUsersByRolesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByRoles, roleIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByRolesRow{}
	for rows.Next() {
		var i GetUsersByRolesRow
		if err := rows.Scan(&i.UserID, &i.NamaUser, &i.RoleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctUserKehadiran = `-- name: ListDistinctUserKehadiran :many
SELECT DISTINCT
  u.id AS user_id,
  u.nama AS nama
FROM kehadiran k
JOIN users u ON u.id = k.user_id
WHERE
  k.deleted_at IS NULL
  AND ($1::uuid IS NULL OR k.kontrak_id = $1::uuid)
  AND ($2::uuid IS NULL OR k.mata_kuliah_id = $2::uuid)
  AND ($3::uuid IS NULL OR k.pembimbing_id = $3::uuid)
  AND ($4::uuid IS NULL OR k.pembimbing_klinik = $4::uuid)
  AND k.tgl_kehadiran BETWEEN '2025-10-10'::date AND '2025-10-26'::date
ORDER BY u.nama ASC
LIMIT $6
OFFSET $5
`

type ListDistinctUserKehadiranParams struct {
	KontrakID        *uuid.UUID `json:"kontrak_id"`
	MataKuliahID     *uuid.UUID `json:"mata_kuliah_id"`
	PembimbingID     *uuid.UUID `json:"pembimbing_id"`
	PembimbingKlinik *uuid.UUID `json:"pembimbing_klinik"`
	Offset           int32      `json:"offset"`
	Limit            int32      `json:"limit"`
}

type ListDistinctUserKehadiranRow struct {
	UserID uuid.UUID `json:"user_id"`
	Nama   string    `json:"nama"`
}

func (q *Queries) ListDistinctUserKehadiran(ctx context.Context, arg ListDistinctUserKehadiranParams) ([]ListDistinctUserKehadiranRow, error) {
	rows, err := q.db.Query(ctx, listDistinctUserKehadiran,
		arg.KontrakID,
		arg.MataKuliahID,
		arg.PembimbingID,
		arg.PembimbingKlinik,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDistinctUserKehadiranRow{}
	for rows.Next() {
		var i ListDistinctUserKehadiranRow
		if err := rows.Scan(&i.UserID, &i.Nama); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
  u.id,
  u.nama,
  u.username,
  u.last_active,
  u.is_active,
  u.locked_until,
  u.failed_attempts,
  u.last_failed_at,
  u.created_by,
  u.created_at,
  COALESCE(string_agg(DISTINCT r.nama, ', '), '')::text AS roles,
  COALESCE(string_agg(DISTINCT r.tag, ', '), '')::text AS tags
FROM public.users u
LEFT JOIN public.r5_user_roles ur
  ON u.id = ur.user_id
LEFT JOIN public.r4_roles r
  ON ur.role_id = r.id    
WHERE 
  u.deleted_at IS NULL
  AND ($1::text IS NULL OR u.nama ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR u.username ILIKE '%' || $2 || '%')
  AND ($3::boolean IS NULL OR u.is_active = $3::boolean)
  AND (
    $4::int[] IS NULL 
    OR array_length($4::int[], 1) IS NULL 
    OR ur.role_id = ANY($4::int[])
  )
GROUP BY
  u.id,
  u.nama,
  u.username,
  u.last_active,
  u.is_active,
  u.locked_until,
  u.failed_attempts,
  u.last_failed_at,
  u.created_by,
  u.created_at
ORDER BY
  CASE WHEN $5::text = 'nama' AND $6::text = 'asc'  THEN u.nama END ASC,
  CASE WHEN $5::text = 'nama' AND $6::text = 'desc' THEN u.nama END DESC,
  CASE WHEN $5::text = 'username' AND $6::text = 'asc'  THEN u.username END ASC,
  CASE WHEN $5::text = 'username' AND $6::text = 'desc' THEN u.username END DESC,
  CASE WHEN $5::text = 'created_at' AND $6::text = 'asc'  THEN u.created_at END ASC,
  CASE WHEN $5::text = 'created_at' AND $6::text = 'desc' THEN u.created_at END DESC
LIMIT $8
OFFSET $7
`

type ListUsersParams struct {
	Nama     *string `json:"nama"`
	Username *string `json:"username"`
	IsActive *bool   `json:"is_active"`
	Roles    []int32 `json:"roles"`
	OrderBy  *string `json:"order_by"`
	Sort     *string `json:"sort"`
	Offset   int32   `json:"offset"`
	Limit    int32   `json:"limit"`
}

type ListUsersRow struct {
	ID             uuid.UUID          `json:"id"`
	Nama           string             `json:"nama"`
	Username       string             `json:"username"`
	LastActive     pgtype.Timestamptz `json:"last_active"`
	IsActive       bool               `json:"is_active"`
	LockedUntil    pgtype.Timestamptz `json:"locked_until"`
	FailedAttempts *int32             `json:"failed_attempts"`
	LastFailedAt   pgtype.Timestamptz `json:"last_failed_at"`
	CreatedBy      *string            `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Roles          string             `json:"roles"`
	Tags           string             `json:"tags"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.Nama,
		arg.Username,
		arg.IsActive,
		arg.Roles,
		arg.OrderBy,
		arg.Sort,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nama,
			&i.Username,
			&i.LastActive,
			&i.IsActive,
			&i.LockedUntil,
			&i.FailedAttempts,
			&i.LastFailedAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Roles,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDelUser = `-- name: SoftDelUser :exec
UPDATE users SET deleted_at = NOW() WHERE username = $1
`

func (q *Queries) SoftDelUser(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, softDelUser, username)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET is_active = $1 WHERE username = $2
`

type UpdateUserActiveParams struct {
	IsActive bool   `json:"is_active"`
	Username string `json:"username"`
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Username)
	return err
}

const updateUserPartial = `-- name: UpdateUserPartial :exec
UPDATE users
SET 
    nama        = COALESCE($1, nama),
    is_active   = COALESCE($2, is_active),
    password    = COALESCE($3, password),
    refresh     = COALESCE($4, refresh),
    updated_note= COALESCE($5, updated_note),
    updated_by  = COALESCE($6, updated_by),
    updated_at  = now()
WHERE id = $7
`

type UpdateUserPartialParams struct {
	Nama        *string   `json:"nama"`
	IsActive    *bool     `json:"is_active"`
	Password    *string   `json:"password"`
	Refresh     *string   `json:"refresh"`
	UpdatedNote *string   `json:"updated_note"`
	UpdatedBy   *string   `json:"updated_by"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPartial(ctx context.Context, arg UpdateUserPartialParams) error {
	_, err := q.db.Exec(ctx, updateUserPartial,
		arg.Nama,
		arg.IsActive,
		arg.Password,
		arg.Refresh,
		arg.UpdatedNote,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const usersFindById = `-- name: UsersFindById :one
SELECT u.id,
       u.username,
       u.password,
	     u.nama,
       u.refresh,
       COALESCE(string_agg(DISTINCT ur.tag, ', '), '')::text AS role
       FROM users u
LEFT JOIN r5_user_roles uur ON uur.user_id = u.id AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur ON ur.id = uur.role_id AND ur.deleted_at IS NULL
WHERE u.id = $1
  AND u.deleted_at IS NULL
GROUP BY u.id, u.username, u.password, u.nama
`

type UsersFindByIdRow struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Password string    `json:"password"`
	Nama     string    `json:"nama"`
	Refresh  *string   `json:"refresh"`
	Role     string    `json:"role"`
}

func (q *Queries) UsersFindById(ctx context.Context, id uuid.UUID) (UsersFindByIdRow, error) {
	row := q.db.QueryRow(ctx, usersFindById, id)
	var i UsersFindByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Nama,
		&i.Refresh,
		&i.Role,
	)
	return i, err
}

const usersFindByUsername = `-- name: UsersFindByUsername :one
SELECT 
    u.id,
    u.username,
    u.password,
    u.nama,
    COALESCE(string_agg(DISTINCT ur.tag, ', '), '')::text AS role
    
FROM users u
LEFT JOIN r5_user_roles uur ON uur.user_id = u.id AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur ON ur.id = uur.role_id AND ur.deleted_at IS NULL
WHERE u.username = $1
  AND u.deleted_at IS NULL
GROUP BY u.id, u.username, u.password, u.nama
`

type UsersFindByUsernameRow struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Password string    `json:"password"`
	Nama     string    `json:"nama"`
	Role     string    `json:"role"`
}

func (q *Queries) UsersFindByUsername(ctx context.Context, username string) (UsersFindByUsernameRow, error) {
	row := q.db.QueryRow(ctx, usersFindByUsername, username)
	var i UsersFindByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Nama,
		&i.Role,
	)
	return i, err
}
