// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 02_users.sql

package pg

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)::bigint
FROM public.users
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR nama ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR username ILIKE '%' || $2 || '%')
  AND ($3::boolean IS NULL OR is_active = $3::boolean)
`

type CountUsersParams struct {
	Nama     *string `json:"nama"`
	Username *string `json:"username"`
	IsActive *bool   `json:"is_active"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.Nama, arg.Username, arg.IsActive)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (
  nama,
  username,
  password
) VALUES (
  $1,$2,$3
) ON CONFLICT (username) DO UPDATE SET 
nama = $1,
password = $3
RETURNING id, nama, username, password, last_active, is_active, locked_until, failed_attempts, last_failed_at, refresh, deleted_by, deleted_at, updated_note, updated_by, updated_at, created_by, created_at, CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type CreateOrUpdateUserParams struct {
	Nama     string `json:"nama"`
	Username string `json:"username"`
	Password string `json:"password"`
}

type CreateOrUpdateUserRow struct {
	ID             uuid.UUID          `json:"id"`
	Nama           string             `json:"nama"`
	Username       string             `json:"username"`
	Password       string             `json:"password"`
	LastActive     pgtype.Timestamptz `json:"last_active"`
	IsActive       bool               `json:"is_active"`
	LockedUntil    pgtype.Timestamptz `json:"locked_until"`
	FailedAttempts *int32             `json:"failed_attempts"`
	LastFailedAt   pgtype.Timestamptz `json:"last_failed_at"`
	Refresh        *string            `json:"refresh"`
	DeletedBy      *string            `json:"deleted_by"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	UpdatedNote    *string            `json:"updated_note"`
	UpdatedBy      *string            `json:"updated_by"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	CreatedBy      *string            `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Operation      string             `json:"operation"`
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (CreateOrUpdateUserRow, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser, arg.Nama, arg.Username, arg.Password)
	var i CreateOrUpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.Password,
		&i.LastActive,
		&i.IsActive,
		&i.LockedUntil,
		&i.FailedAttempts,
		&i.LastFailedAt,
		&i.Refresh,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedNote,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Operation,
	)
	return i, err
}

const delUser = `-- name: DelUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DelUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delUser, id)
	return err
}

const getByUsername = `-- name: GetByUsername :one
SELECT username,password FROM users
WHERE username = $1
`

type GetByUsernameRow struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) GetByUsername(ctx context.Context, username string) (GetByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getByUsername, username)
	var i GetByUsernameRow
	err := row.Scan(&i.Username, &i.Password)
	return i, err
}

const getUserActiveStatus = `-- name: GetUserActiveStatus :one
SELECT is_active FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserActiveStatus(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, getUserActiveStatus, username)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, nama, username, password, last_active, is_active, locked_until, failed_attempts, last_failed_at, refresh, deleted_by, deleted_at, updated_note, updated_by, updated_at, created_by, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.Password,
		&i.LastActive,
		&i.IsActive,
		&i.LockedUntil,
		&i.FailedAttempts,
		&i.LastFailedAt,
		&i.Refresh,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedNote,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserDetail = `-- name: GetUserDetail :one
SELECT 
  u.id,
  u.nama,
  u.username,
  u.last_active,
  u.is_active,
  u.created_by,
  u.created_at,
  COALESCE(string_agg(DISTINCT ur.nama, ', '), '')::text AS roles
FROM users u
LEFT JOIN r5_user_roles uur 
  ON uur.user_id = u.id 
  AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur 
  ON ur.id = uur.role_id 
  AND ur.deleted_at IS NULL
WHERE u.id = $1
GROUP BY u.id, u.nama, u.username, u.last_active, u.is_active, u.created_by, u.created_at
`

type GetUserDetailRow struct {
	ID         uuid.UUID          `json:"id"`
	Nama       string             `json:"nama"`
	Username   string             `json:"username"`
	LastActive pgtype.Timestamptz `json:"last_active"`
	IsActive   bool               `json:"is_active"`
	CreatedBy  *string            `json:"created_by"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Roles      string             `json:"roles"`
}

func (q *Queries) GetUserDetail(ctx context.Context, id uuid.UUID) (GetUserDetailRow, error) {
	row := q.db.QueryRow(ctx, getUserDetail, id)
	var i GetUserDetailRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Username,
		&i.LastActive,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Roles,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT
  id,
  nama,
  username,
  last_active,
  is_active,
  locked_until,
  failed_attempts,
  last_failed_at,
  created_by,
  created_at
FROM public.users
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR nama ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR username ILIKE '%' || $2 || '%')
  AND ($3::boolean IS NULL OR is_active = $3::boolean)
ORDER BY
  CASE WHEN $4::text = 'nama' AND $5::text = 'asc'  THEN nama END ASC,
  CASE WHEN $4::text = 'nama' AND $5::text = 'desc' THEN nama END DESC,
  CASE WHEN $4::text = 'username' AND $5::text = 'asc'  THEN username END ASC,
  CASE WHEN $4::text = 'username' AND $5::text = 'desc' THEN username END DESC,
  CASE WHEN $4::text = 'created_at' AND $5::text = 'asc'  THEN created_at END ASC,
  CASE WHEN $4::text = 'created_at' AND $5::text = 'desc' THEN created_at END DESC
LIMIT $7
OFFSET $6
`

type ListUsersParams struct {
	Nama     *string `json:"nama"`
	Username *string `json:"username"`
	IsActive *bool   `json:"is_active"`
	OrderBy  *string `json:"order_by"`
	Sort     *string `json:"sort"`
	Offset   int32   `json:"offset"`
	Limit    int32   `json:"limit"`
}

type ListUsersRow struct {
	ID             uuid.UUID          `json:"id"`
	Nama           string             `json:"nama"`
	Username       string             `json:"username"`
	LastActive     pgtype.Timestamptz `json:"last_active"`
	IsActive       bool               `json:"is_active"`
	LockedUntil    pgtype.Timestamptz `json:"locked_until"`
	FailedAttempts *int32             `json:"failed_attempts"`
	LastFailedAt   pgtype.Timestamptz `json:"last_failed_at"`
	CreatedBy      *string            `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.Nama,
		arg.Username,
		arg.IsActive,
		arg.OrderBy,
		arg.Sort,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nama,
			&i.Username,
			&i.LastActive,
			&i.IsActive,
			&i.LockedUntil,
			&i.FailedAttempts,
			&i.LastFailedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDelUser = `-- name: SoftDelUser :exec
UPDATE users SET deleted_at = NOW() WHERE username = $1
`

func (q *Queries) SoftDelUser(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, softDelUser, username)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET is_active = $1 WHERE username = $2
`

type UpdateUserActiveParams struct {
	IsActive bool   `json:"is_active"`
	Username string `json:"username"`
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Username)
	return err
}

const updateUserPartial = `-- name: UpdateUserPartial :exec
UPDATE users
SET 
    nama        = COALESCE($1, nama),
    is_active   = COALESCE($2, is_active),
    password    = COALESCE($3, password),
    refresh     = COALESCE($4, refresh),
    updated_note= COALESCE($5, updated_note),
    updated_by  = COALESCE($6, updated_by),
    updated_at  = now()
WHERE id = $7
`

type UpdateUserPartialParams struct {
	Nama        *string   `json:"nama"`
	IsActive    *bool     `json:"is_active"`
	Password    *string   `json:"password"`
	Refresh     *string   `json:"refresh"`
	UpdatedNote *string   `json:"updated_note"`
	UpdatedBy   *string   `json:"updated_by"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPartial(ctx context.Context, arg UpdateUserPartialParams) error {
	_, err := q.db.Exec(ctx, updateUserPartial,
		arg.Nama,
		arg.IsActive,
		arg.Password,
		arg.Refresh,
		arg.UpdatedNote,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const usersFindById = `-- name: UsersFindById :one
SELECT u.id,
       u.username,
       u.password,
	     u.nama,
       u.refresh
       FROM users u
LEFT JOIN r5_user_roles uur ON uur.user_id = u.id AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur ON ur.id = uur.role_id AND ur.deleted_at IS NULL
WHERE u.id = $1
  AND u.deleted_at IS NULL
GROUP BY u.id, u.username, u.password, u.nama
`

type UsersFindByIdRow struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Password string    `json:"password"`
	Nama     string    `json:"nama"`
	Refresh  *string   `json:"refresh"`
}

func (q *Queries) UsersFindById(ctx context.Context, id uuid.UUID) (UsersFindByIdRow, error) {
	row := q.db.QueryRow(ctx, usersFindById, id)
	var i UsersFindByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Nama,
		&i.Refresh,
	)
	return i, err
}

const usersFindByUsername = `-- name: UsersFindByUsername :one
SELECT 
    u.id,
    u.username,
    u.password,
    u.nama,
      COALESCE(
        string_agg(ur.tag, ',' ORDER BY ur.tag), 
        '' 
    ) AS roles,
    COALESCE(
        string_agg(ur.id::text, ',' ORDER BY ur.id::text),
        ''
    ) AS role_ids
FROM users u
LEFT JOIN r5_user_roles uur ON uur.user_id = u.id AND uur.deleted_at IS NULL
LEFT JOIN r4_roles ur ON ur.id = uur.role_id AND ur.deleted_at IS NULL
WHERE u.username = $1
  AND u.deleted_at IS NULL
GROUP BY u.id, u.username, u.password, u.nama
`

type UsersFindByUsernameRow struct {
	ID       uuid.UUID   `json:"id"`
	Username string      `json:"username"`
	Password string      `json:"password"`
	Nama     string      `json:"nama"`
	Roles    interface{} `json:"roles"`
	RoleIds  interface{} `json:"role_ids"`
}

func (q *Queries) UsersFindByUsername(ctx context.Context, username string) (UsersFindByUsernameRow, error) {
	row := q.db.QueryRow(ctx, usersFindByUsername, username)
	var i UsersFindByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Nama,
		&i.Roles,
		&i.RoleIds,
	)
	return i, err
}
