// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 13_r1_views.sql

package pg

import (
	"context"
)

const createR1View = `-- name: CreateR1View :one
INSERT INTO r1_views (
    label, level, parent_id, path, method,
    resource_key, action, view, data,
    is_active, created_by
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    COALESCE($10, true), $11
)
RETURNING id, label, level, parent_id, path, method, resource_key, action, view, data, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type CreateR1ViewParams struct {
	Label       string      `json:"label"`
	Level       *int16      `json:"level"`
	ParentID    *int32      `json:"parent_id"`
	Path        *string     `json:"path"`
	Method      *string     `json:"method"`
	ResourceKey string      `json:"resource_key"`
	Action      string      `json:"action"`
	View        *string     `json:"view"`
	Data        *string     `json:"data"`
	Column10    interface{} `json:"column_10"`
	CreatedBy   *string     `json:"created_by"`
}

func (q *Queries) CreateR1View(ctx context.Context, arg CreateR1ViewParams) (R1View, error) {
	row := q.db.QueryRow(ctx, createR1View,
		arg.Label,
		arg.Level,
		arg.ParentID,
		arg.Path,
		arg.Method,
		arg.ResourceKey,
		arg.Action,
		arg.View,
		arg.Data,
		arg.Column10,
		arg.CreatedBy,
	)
	var i R1View
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Level,
		&i.ParentID,
		&i.Path,
		&i.Method,
		&i.ResourceKey,
		&i.Action,
		&i.View,
		&i.Data,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteR1View = `-- name: DeleteR1View :exec
UPDATE r1_views
SET deleted_at = now(),
    deleted_by = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteR1ViewParams struct {
	ID        int32   `json:"id"`
	DeletedBy *string `json:"deleted_by"`
}

func (q *Queries) DeleteR1View(ctx context.Context, arg DeleteR1ViewParams) error {
	_, err := q.db.Exec(ctx, deleteR1View, arg.ID, arg.DeletedBy)
	return err
}

const getR1View = `-- name: GetR1View :one
SELECT id, label, level, parent_id, path, method, resource_key, action, view, data, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r1_views
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetR1View(ctx context.Context, id int32) (R1View, error) {
	row := q.db.QueryRow(ctx, getR1View, id)
	var i R1View
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Level,
		&i.ParentID,
		&i.Path,
		&i.Method,
		&i.ResourceKey,
		&i.Action,
		&i.View,
		&i.Data,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getR1ViewRecursive = `-- name: GetR1ViewRecursive :many
SELECT 
    id,
    label,
    parent_id,
    resource_key,
    action,
    view,
    data,
    level,
    path
FROM r1_views
WHERE view = 'view'
ORDER BY level, id
`

type GetR1ViewRecursiveRow struct {
	ID          int32   `json:"id"`
	Label       string  `json:"label"`
	ParentID    *int32  `json:"parent_id"`
	ResourceKey string  `json:"resource_key"`
	Action      string  `json:"action"`
	View        *string `json:"view"`
	Data        *string `json:"data"`
	Level       *int16  `json:"level"`
	Path        *string `json:"path"`
}

func (q *Queries) GetR1ViewRecursive(ctx context.Context) ([]GetR1ViewRecursiveRow, error) {
	rows, err := q.db.Query(ctx, getR1ViewRecursive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetR1ViewRecursiveRow{}
	for rows.Next() {
		var i GetR1ViewRecursiveRow
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.ParentID,
			&i.ResourceKey,
			&i.Action,
			&i.View,
			&i.Data,
			&i.Level,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewsByIdsWithChildren = `-- name: GetViewsByIdsWithChildren :many
SELECT v.id,
       v.resource_key,
       v.action,
       v.view
FROM r1_views v
WHERE (v.resource_key, v.action) IN (
    SELECT rv.resource_key, rv.action
    FROM r1_views rv
    WHERE rv.id = ANY($1::int[])
)
AND v.is_active = true
AND v.deleted_at IS NULL
`

type GetViewsByIdsWithChildrenRow struct {
	ID          int32   `json:"id"`
	ResourceKey string  `json:"resource_key"`
	Action      string  `json:"action"`
	View        *string `json:"view"`
}

func (q *Queries) GetViewsByIdsWithChildren(ctx context.Context, ids []int32) ([]GetViewsByIdsWithChildrenRow, error) {
	rows, err := q.db.Query(ctx, getViewsByIdsWithChildren, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetViewsByIdsWithChildrenRow{}
	for rows.Next() {
		var i GetViewsByIdsWithChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceKey,
			&i.Action,
			&i.View,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteR1View = `-- name: HardDeleteR1View :exec
DELETE FROM r1_views
WHERE id = $1
`

func (q *Queries) HardDeleteR1View(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, hardDeleteR1View, id)
	return err
}

const listR1Views = `-- name: ListR1Views :many
SELECT id, label, level, parent_id, path, method, resource_key, action, view, data, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r1_views
WHERE deleted_at IS NULL 
AND ($1::text IS NULL OR label ILIKE '%' || $1 || '%')
ORDER BY id
`

func (q *Queries) ListR1Views(ctx context.Context, label *string) ([]R1View, error) {
	rows, err := q.db.Query(ctx, listR1Views, label)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []R1View{}
	for rows.Next() {
		var i R1View
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Level,
			&i.ParentID,
			&i.Path,
			&i.Method,
			&i.ResourceKey,
			&i.Action,
			&i.View,
			&i.Data,
			&i.IsActive,
			&i.DeletedBy,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateR1View = `-- name: UpdateR1View :one
UPDATE r1_views
SET 
    label = COALESCE($1, label),
    level = COALESCE($2, level),
    parent_id = COALESCE($3, parent_id),
    path = COALESCE($4, path),
    method = COALESCE($5, method),
    resource_key = COALESCE($6, resource_key),
    action = COALESCE($7, action),
    view = COALESCE($8, view),
    data = COALESCE($9, data),
    is_active = COALESCE($10, is_active),
    updated_by = $11,
    updated_at = now()
WHERE id = $12
RETURNING id, label, level, parent_id, path, method, resource_key, action, view, data, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type UpdateR1ViewParams struct {
	Label       string  `json:"label"`
	Level       *int16  `json:"level"`
	ParentID    *int32  `json:"parent_id"`
	Path        *string `json:"path"`
	Method      *string `json:"method"`
	ResourceKey string  `json:"resource_key"`
	Action      string  `json:"action"`
	View        *string `json:"view"`
	Data        *string `json:"data"`
	IsActive    bool    `json:"is_active"`
	UpdatedBy   *string `json:"updated_by"`
	ID          int32   `json:"id"`
}

func (q *Queries) UpdateR1View(ctx context.Context, arg UpdateR1ViewParams) (R1View, error) {
	row := q.db.QueryRow(ctx, updateR1View,
		arg.Label,
		arg.Level,
		arg.ParentID,
		arg.Path,
		arg.Method,
		arg.ResourceKey,
		arg.Action,
		arg.View,
		arg.Data,
		arg.IsActive,
		arg.UpdatedBy,
		arg.ID,
	)
	var i R1View
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Level,
		&i.ParentID,
		&i.Path,
		&i.Method,
		&i.ResourceKey,
		&i.Action,
		&i.View,
		&i.Data,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}
