// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: 15_r4_roles.sql

package pg

import (
	"context"
)

const createR4Role = `-- name: CreateR4Role :one
INSERT INTO r4_roles (
  id, tag, nama, created_by,created_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  now()
)
RETURNING id, tag, nama, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type CreateR4RoleParams struct {
	ID        int32   `json:"id"`
	Tag       string  `json:"tag"`
	Nama      string  `json:"nama"`
	CreatedBy *string `json:"created_by"`
}

func (q *Queries) CreateR4Role(ctx context.Context, arg CreateR4RoleParams) (R4Role, error) {
	row := q.db.QueryRow(ctx, createR4Role,
		arg.ID,
		arg.Tag,
		arg.Nama,
		arg.CreatedBy,
	)
	var i R4Role
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.Nama,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteR4Role = `-- name: DeleteR4Role :exec
UPDATE r4_roles
SET
  deleted_by = $1,
  deleted_at = now()
WHERE id = $2
  AND deleted_at IS NULL
`

type DeleteR4RoleParams struct {
	DeletedBy *string `json:"deleted_by"`
	ID        int32   `json:"id"`
}

func (q *Queries) DeleteR4Role(ctx context.Context, arg DeleteR4RoleParams) error {
	_, err := q.db.Exec(ctx, deleteR4Role, arg.DeletedBy, arg.ID)
	return err
}

const getR4RoleByID = `-- name: GetR4RoleByID :one
SELECT id, tag, nama, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r4_roles
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetR4RoleByID(ctx context.Context, id int32) (R4Role, error) {
	row := q.db.QueryRow(ctx, getR4RoleByID, id)
	var i R4Role
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.Nama,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listR4Roles = `-- name: ListR4Roles :many
SELECT id, tag, nama, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
FROM r4_roles
WHERE deleted_at IS NULL
ORDER BY id
`

func (q *Queries) ListR4Roles(ctx context.Context) ([]R4Role, error) {
	rows, err := q.db.Query(ctx, listR4Roles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []R4Role{}
	for rows.Next() {
		var i R4Role
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.Nama,
			&i.IsActive,
			&i.DeletedBy,
			&i.DeletedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateR4Role = `-- name: UpdateR4Role :one
UPDATE r4_roles
SET
  tag = COALESCE($1, tag),
  nama = COALESCE($2, nama),
  is_active = COALESCE($3, is_active),
  updated_by = $4,
  updated_at = now()
WHERE id = $5
  AND deleted_at IS NULL
RETURNING id, tag, nama, is_active, deleted_by, deleted_at, updated_by, updated_at, created_by, created_at
`

type UpdateR4RoleParams struct {
	Tag       *string `json:"tag"`
	Nama      *string `json:"nama"`
	IsActive  *bool   `json:"is_active"`
	UpdatedBy *string `json:"updated_by"`
	ID        int32   `json:"id"`
}

func (q *Queries) UpdateR4Role(ctx context.Context, arg UpdateR4RoleParams) (R4Role, error) {
	row := q.db.QueryRow(ctx, updateR4Role,
		arg.Tag,
		arg.Nama,
		arg.IsActive,
		arg.UpdatedBy,
		arg.ID,
	)
	var i R4Role
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.Nama,
		&i.IsActive,
		&i.DeletedBy,
		&i.DeletedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}
